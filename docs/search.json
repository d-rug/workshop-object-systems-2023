[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R’s object systems",
    "section": "",
    "text": "1 Overview\nThis mini-workshop is intended to introduce you to R’s object systems. There are actually a lot of them, but we are going to focus on the two or three most important ones. My goal is to answer some very basic questions, like:\n\nWhat is an object system and why does R need one?\nWhy does R have so many object systems?\nHow do I know what object system is relevant for my work?\nHow do I interact with the most common object systems?"
  },
  {
    "objectID": "01_Introduction.html",
    "href": "01_Introduction.html",
    "title": "2  Introduction",
    "section": "",
    "text": "As a statistician and data scientist, the objects I interact with most often in R are data frames and regression models. Actually R’s numbers and vectors are “objects” of a sort, but not in the sense that they need an object system. You can see the difference here:\n\n# you can check whether something is an object with is.object()\nis.object( c(\"a\", \"b\", \"c\") )\n\n[1] FALSE\n\nis.object( 13 )\n\n[1] FALSE\n\nis.object( data.frame() )\n\n[1] TRUE\n\n# to be an object means to have a class:\nattr( c(\"a\", \"b\", \"c\"), \"class\")\n\nNULL\n\nattr( 13, \"class\")\n\nNULL\n\nattr( data.frame(), \"class\")\n\n[1] \"data.frame\"\n\n\nObjects are the nouns of a computer language. They provide two main functions: encapsulation and polymorphism.\n\nEncapsulation: many different parts can be bundled together into a single object.\nPolymorphism: you can do many different things using functions that share the same name (e.g., plot())."
  },
  {
    "objectID": "02_Example.html#penguin-data",
    "href": "02_Example.html#penguin-data",
    "title": "Example: penguins",
    "section": "Penguin data",
    "text": "Penguin data\nBegin by installing the palmerpenguins package from Allison Horst’s Github. Then load the package and import the data.\n\n# install the palmerpenguins package\nremotes::install_github(\"allisonhorst/palmerpenguins\")\nlibrary( \"palmerpenguins\" )\ndata( penguins )"
  },
  {
    "objectID": "02_Example.html#estimate-a-linear-model",
    "href": "02_Example.html#estimate-a-linear-model",
    "title": "Example: penguins",
    "section": "Estimate a linear model",
    "text": "Estimate a linear model\nHere’s a common task: estimate a linear regression model for some data. The result is an object (one that uses the S3 system)\n\n# make a linear regression model:\npenguin_lm = lm( body_mass_g ~ species + sex, data=penguins )\n\n# check the lm object:\nis.object( penguin_lm )\n\n[1] TRUE\n\nattr( penguin_lm, \"class\" )\n\n[1] \"lm\"\n\nclass( penguin_lm )\n\n[1] \"lm\""
  },
  {
    "objectID": "02_Example.html#the-plot-function-does-more-than-one-thing",
    "href": "02_Example.html#the-plot-function-does-more-than-one-thing",
    "title": "Example: penguins",
    "section": "The plot() function does more than one thing",
    "text": "The plot() function does more than one thing\nWhat happens when you call the plot() function depends on what kind of object you are plotting. This had to be built into R! Functions only do what they are told, so how can plot() do different things?!\n\n# plot the data and the model\nplot( penguins )\n\n\n\nlayout( matrix(1:4, 2, 2))\nplot( penguin_lm )"
  },
  {
    "objectID": "02_Example.html#the-summary-function-does-more-than-one-thing",
    "href": "02_Example.html#the-summary-function-does-more-than-one-thing",
    "title": "Example: penguins",
    "section": "The summary() function does more than one thing",
    "text": "The summary() function does more than one thing\nSimilarly, the summary() function can do different things depending on what object it works on. On a data.frame, summary() will summarize each column. Called on a fitted linear model, summary() will tell you about the coefficients, their significange levels, and calculate the model’s R-squared.\n\n# summarize the data and the model\nsummary( penguins )\n\n      species          island    bill_length_mm  bill_depth_mm  \n Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  \n Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  \n Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  \n                                 Mean   :43.92   Mean   :17.15  \n                                 3rd Qu.:48.50   3rd Qu.:18.70  \n                                 Max.   :59.60   Max.   :21.50  \n                                 NA's   :2       NA's   :2      \n flipper_length_mm  body_mass_g       sex           year     \n Min.   :172.0     Min.   :2700   female:165   Min.   :2007  \n 1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  \n Median :197.0     Median :4050   NA's  : 11   Median :2008  \n Mean   :200.9     Mean   :4202                Mean   :2008  \n 3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  \n Max.   :231.0     Max.   :6300                Max.   :2009  \n NA's   :2         NA's   :2                                 \n\nsummary( penguin_lm )\n\n\nCall:\nlm(formula = body_mass_g ~ species + sex, data = penguins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-816.87 -217.80  -16.87  227.61  882.20 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       3372.39      31.43 107.308   <2e-16 ***\nspeciesChinstrap    26.92      46.48   0.579    0.563    \nspeciesGentoo     1377.86      39.10  35.236   <2e-16 ***\nsexmale            667.56      34.70  19.236   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 316.6 on 329 degrees of freedom\n  (11 observations deleted due to missingness)\nMultiple R-squared:  0.8468,    Adjusted R-squared:  0.8454 \nF-statistic: 606.1 on 3 and 329 DF,  p-value: < 2.2e-16"
  },
  {
    "objectID": "02_Example.html#an-lm-object-encapsulates-many-pieces",
    "href": "02_Example.html#an-lm-object-encapsulates-many-pieces",
    "title": "Example: penguins",
    "section": "An lm object encapsulates many pieces",
    "text": "An lm object encapsulates many pieces\nThe linear model object penguin_lm contains a lot of pieces. You can see the names of the pieces by using the names() function.\n\n# access some pieces that are encapsulated in the model:\nnames( penguin_lm )\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"na.action\"     \"contrasts\"     \"xlevels\"       \"call\"         \n[13] \"terms\"         \"model\"        \n\npenguin_lm$coefficients\n\n     (Intercept) speciesChinstrap    speciesGentoo          sexmale \n      3372.38681         26.92385       1377.85803        667.55515 \n\npenguin_lm$call\n\nlm(formula = body_mass_g ~ species + sex, data = penguins)"
  },
  {
    "objectID": "03_S3_vs_S4.html#s3",
    "href": "03_S3_vs_S4.html#s3",
    "title": "3  S3 vs S4",
    "section": "3.1 S3",
    "text": "3.1 S3\nS3 is used by the most common R modeling methods like lm() and glm(). You access elements of the objects using the dollar-sign, like my_model$coefficients.\nThe S3 object system is very loosey-goosey. This happened because R wasn’t developed with the intention of having an object system, so S3 was pieced together from parts that were already there in the language, but intended for other purposes. Here is how easy it is to create a whole new S3 class and an object of the class, including members and methods:\n\nmy_obj = list()\nmy_obj$a = 1:4\nmy_obj$b = 10:7\n\n# turn my_obj into an object by assigning it a class name\nclass(my_obj) = \"dumb\"\n\n# define a plot method for the class\nplot.dumb = function( obj ) plot(obj$a, obj$b)\nplot(my_obj)\n\n\n\n\nThis flexibility is very liberating, but can also cause problems. There is nothing that enforces the expectation that object of class dumb must have members a and b, so you can crash the plot() method:\n\nobj2 = list()\nobj2$message = \"No bloody a, b, or c\"\n\n# turn my_obj into an object by assigning it a class name\nclass(obj2) = \"dumb\"\n\n# define a plot method for the class\nplot.dumb = function( obj ) plot(obj$a, obj$b)\nplot(obj2)\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nError in plot.window(...): need finite 'xlim' values\n\n\n\n\n\nThe S4 object system was developed in order to impose some order to the chaos.\n##S4 Used by lme4 and Bioconductor. The S4 object system is much more formal than S3 - a class must be fully defined before it can be used, and objects can only be modified through their methods. We aren’t going to create a new S4 class because it is much more complicated that the S3 example. Instead, let’s generate a mixed-effects model using the lmer() function from the lme4 package.\n\ninstall.packages( \"lme4\" )\n\n\nThe downloaded binary packages are in\n    /var/folders/7x/s3x3ymxs1_lcppnqy99_4kx40000gp/T//RtmpfwJWvr/downloaded_packages\n\nlibrary(lme4)\n\n\n# estimate the linear, mixed-effects model:\npeng_lme = lmer( body_mass_g ~ species + sex + (1|island), data=penguins )\n\nboundary (singular) fit: see help('isSingular')\n\n\nThe easiest way to know that peng_lme is an S4 object is that it is listed as a “Formal class” in the “Environment” pane of RStudio.\n\n\n\nFigure 3.1: This is how an S4 class is listed in the Environment pane of RStudio\n\n\nThe next most visible difference is that you can’t use $ to access the members that are encapsulated by an S4 class. Instead, you use @ or the slot() function:\n\n# inspect the slot \"beta\"\npeng_lme@beta\n\n[1] 3372.38681   26.92385 1377.85803  667.55515\n\n# the preferred way to do the same:\nslot(peng_lme, \"beta\")\n\n[1] 3372.38681   26.92385 1377.85803  667.55515\n\n# You get an error if you try using $ to access a slot:\npeng_lme$beta\n\nError in peng_lme$beta: $ operator not defined for this S4 class\n\n\nAnother thing you may notice is that you can’t change the structure of an S4 object:\n\n# get an error if you try to conjure a new slot:\npeng_lme@test = 5\n\nError in (function (cl, name, valueClass) : 'test' is not a slot in class \"lmerMod\""
  },
  {
    "objectID": "04_Commonalities.html",
    "href": "04_Commonalities.html",
    "title": "4  How S3 and S4 methods work",
    "section": "",
    "text": "Both S3 and S4 accomplish the goals of encapsulation and polymorphism. In fact, the polymorphism is accomplished in nearly the same way.\nIn object-oriented programming, a method is a function that belongs to an object. R’s handling of methods is an extremely important way that the language is flexible and intuitive. When you call the plot() function, you call a generic method that decides what specific method should be used based on the object’s class name. First, let’s recall that you can see the code for a function by writing the function name without parentheses:\n\n# function without parentheses prints the code:\nplot\n\nfunction (x, y, ...) \nUseMethod(\"plot\")\n<bytecode: 0x7f7f782f3b58>\n<environment: namespace:base>\n\n\nThe UseMethod(\"plot\") part causes R to select from all the functions named like plot.<classname>(), which you can list this way:\n\nmethods(plot)\n\n [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*\n [4] plot.default        plot.dendrogram*    plot.density*      \n [7] plot.ecdf           plot.factor*        plot.formula*      \n[10] plot.function       plot.hclust*        plot.histogram*    \n[13] plot.HoltWinters*   plot.isoreg*        plot.lm*           \n[16] plot.medpolish*     plot.mlm*           plot.ppr*          \n[19] plot.prcomp*        plot.princomp*      plot.profile.nls*  \n[22] plot.raster*        plot.spec*          plot.stepfun       \n[25] plot.stl*           plot.table*         plot.ts            \n[28] plot.tskernel*      plot.TukeyHSD*     \nsee '?methods' for accessing help and source code\n\n\nLet’s see the code that actually does the work of plot.lm() and plot.merMod():\n\nstats:::plot.lm\n\nfunction (x, which = c(1, 2, 3, 5), caption = list(\"Residuals vs Fitted\", \n    \"Normal Q-Q\", \"Scale-Location\", \"Cook's distance\", \"Residuals vs Leverage\", \n    expression(\"Cook's dist vs Leverage* \" * h[ii]/(1 - h[ii]))), \n    panel = if (add.smooth) function(x, y, ...) panel.smooth(x, \n        y, iter = iter.smooth, ...) else points, sub.caption = NULL, \n    main = \"\", ask = prod(par(\"mfcol\")) < length(which) && dev.interactive(), \n    ..., id.n = 3, labels.id = names(residuals(x)), cex.id = 0.75, \n    qqline = TRUE, cook.levels = c(0.5, 1), cook.col = 8, cook.lty = 2, \n    cook.legendChanges = list(), add.smooth = getOption(\"add.smooth\"), \n    iter.smooth = if (isGlm) 0 else 3, label.pos = c(4, 2), cex.caption = 1, \n    cex.oma.main = 1.25, extend.ylim.f = 0.08) \n{\n    dropInf <- function(x, h) {\n        if (any(isInf <- h >= 1)) {\n            warning(gettextf(\"not plotting observations with leverage one:\\n  %s\", \n                paste(which(isInf), collapse = \", \")), call. = FALSE, \n                domain = NA)\n            x[isInf] <- NaN\n        }\n        x\n    }\n    if (!inherits(x, \"lm\")) \n        stop(\"use only with \\\"lm\\\" objects\")\n    if (!is.numeric(which) || any(which < 1) || any(which > 6)) \n        stop(\"'which' must be in 1:6\")\n    if ((isGlm <- inherits(x, \"glm\"))) \n        binomialLike <- family(x)$family == \"binomial\"\n    show <- rep(FALSE, 6)\n    show[which] <- TRUE\n    r <- if (isGlm) \n        residuals(x, type = \"pearson\")\n    else residuals(x)\n    yh <- predict(x)\n    w <- weights(x)\n    if (!is.null(w)) {\n        wind <- w != 0\n        r <- r[wind]\n        yh <- yh[wind]\n        w <- w[wind]\n        labels.id <- labels.id[wind]\n    }\n    n <- length(r)\n    if (any(show[2L:6L])) {\n        s <- if (inherits(x, \"rlm\")) \n            x$s\n        else if (isGlm) \n            sqrt(summary(x)$dispersion)\n        else sqrt(deviance(x)/df.residual(x))\n        hii <- (infl <- influence(x, do.coef = FALSE))$hat\n        if (any(show[4L:6L])) {\n            cook <- cooks.distance(x, infl)\n        }\n    }\n    if (any(show[c(2L, 3L, 5L)])) {\n        ylab5 <- ylab23 <- if (isGlm) \n            \"Std. Pearson resid.\"\n        else \"Standardized residuals\"\n        rs <- dropInf(if (isGlm) \n            rstandard(x, type = \"pearson\")\n        else (if (is.null(w)) \n            r\n        else sqrt(w) * r)/(s * sqrt(1 - hii)), hii)\n    }\n    if (any(show[5L:6L])) {\n        r.hat <- range(hii, na.rm = TRUE)\n        isConst.hat <- all(r.hat == 0) || diff(r.hat) < 1e-10 * \n            mean(hii, na.rm = TRUE)\n    }\n    if (any(show[c(1L, 3L)])) \n        l.fit <- if (isGlm) \n            \"Predicted values\"\n        else \"Fitted values\"\n    if (is.null(id.n)) \n        id.n <- 0L\n    else {\n        id.n <- as.integer(id.n)\n        if (id.n < 0L || id.n > n) \n            stop(gettextf(\"'id.n' must be in {1,..,%d}\", n), \n                domain = NA)\n    }\n    if (id.n > 0L) {\n        if (is.null(labels.id)) \n            labels.id <- paste(1L:n)\n        iid <- 1L:id.n\n        show.r <- sort.list(abs(r), decreasing = TRUE)[iid]\n        if (any(show[2L:3L])) \n            show.rs <- sort.list(abs(rs), decreasing = TRUE)[iid]\n        text.id <- function(x, y, ind, adj.x = TRUE, usr = par(\"usr\")) {\n            labpos <- if (adj.x) \n                label.pos[(x > mean(usr[1:2])) + 1L]\n            else 3\n            text(x, y, labels.id[ind], cex = cex.id, xpd = TRUE, \n                pos = labpos, offset = 0.25)\n        }\n    }\n    getCaption <- function(k) if (length(caption) < k) \n        NA_character_\n    else as.graphicsAnnot(caption[[k]])\n    if (is.null(sub.caption)) {\n        cal <- x$call\n        if (!is.na(m.f <- match(\"formula\", names(cal)))) {\n            cal <- cal[c(1, m.f)]\n            names(cal)[2L] <- \"\"\n        }\n        cc <- deparse(cal, 80)\n        nc <- nchar(cc[1L], \"c\")\n        abbr <- length(cc) > 1 || nc > 75\n        sub.caption <- if (abbr) \n            paste(substr(cc[1L], 1L, min(75L, nc)), \"...\")\n        else cc[1L]\n    }\n    one.fig <- prod(par(\"mfcol\")) == 1\n    if (ask) {\n        oask <- devAskNewPage(TRUE)\n        on.exit(devAskNewPage(oask))\n    }\n    if (show[1L]) {\n        ylim <- range(r, na.rm = TRUE)\n        if (id.n > 0) \n            ylim <- extendrange(r = ylim, f = extend.ylim.f)\n        dev.hold()\n        plot(yh, r, xlab = l.fit, ylab = \"Residuals\", main = main, \n            ylim = ylim, type = \"n\", ...)\n        panel(yh, r, ...)\n        if (one.fig) \n            title(sub = sub.caption, ...)\n        mtext(getCaption(1), 3, 0.25, cex = cex.caption)\n        if (id.n > 0) {\n            y.id <- r[show.r]\n            y.id[y.id < 0] <- y.id[y.id < 0] - strheight(\" \")/3\n            text.id(yh[show.r], y.id, show.r)\n        }\n        abline(h = 0, lty = 3, col = \"gray\")\n        dev.flush()\n    }\n    if (show[2L]) {\n        ylim <- range(rs, na.rm = TRUE)\n        ylim[2L] <- ylim[2L] + diff(ylim) * 0.075\n        dev.hold()\n        qq <- qqnorm(rs, main = main, ylab = ylab23, ylim = ylim, \n            ...)\n        if (qqline) \n            qqline(rs, lty = 3, col = \"gray50\")\n        if (one.fig) \n            title(sub = sub.caption, ...)\n        mtext(getCaption(2), 3, 0.25, cex = cex.caption)\n        if (id.n > 0) \n            text.id(qq$x[show.rs], qq$y[show.rs], show.rs)\n        dev.flush()\n    }\n    if (show[3L]) {\n        sqrtabsr <- sqrt(abs(rs))\n        ylim <- c(0, max(sqrtabsr, na.rm = TRUE))\n        yl <- as.expression(substitute(sqrt(abs(YL)), list(YL = as.name(ylab23))))\n        yhn0 <- if (is.null(w)) \n            yh\n        else yh[w != 0]\n        dev.hold()\n        plot(yhn0, sqrtabsr, xlab = l.fit, ylab = yl, main = main, \n            ylim = ylim, type = \"n\", ...)\n        panel(yhn0, sqrtabsr, ...)\n        if (one.fig) \n            title(sub = sub.caption, ...)\n        mtext(getCaption(3), 3, 0.25, cex = cex.caption)\n        if (id.n > 0) \n            text.id(yhn0[show.rs], sqrtabsr[show.rs], show.rs)\n        dev.flush()\n    }\n    if (show[4L]) {\n        if (id.n > 0) {\n            show.r <- order(-cook)[iid]\n            ymx <- cook[show.r[1L]] * 1.075\n        }\n        else ymx <- max(cook, na.rm = TRUE)\n        dev.hold()\n        plot(cook, type = \"h\", ylim = c(0, ymx), main = main, \n            xlab = \"Obs. number\", ylab = \"Cook's distance\", ...)\n        if (one.fig) \n            title(sub = sub.caption, ...)\n        mtext(getCaption(4), 3, 0.25, cex = cex.caption)\n        if (id.n > 0) \n            text.id(show.r, cook[show.r], show.r, adj.x = FALSE)\n        dev.flush()\n    }\n    if (show[5L]) {\n        ylim <- range(rs, na.rm = TRUE)\n        if (id.n > 0) {\n            ylim <- extendrange(r = ylim, f = extend.ylim.f)\n            show.rs <- order(-cook)[iid]\n        }\n        do.plot <- TRUE\n        if (isConst.hat) {\n            if (missing(caption)) \n                caption[[5L]] <- \"Constant Leverage:\\n Residuals vs Factor Levels\"\n            if (nf <- length(xlev <- x$xlevels)) {\n                facvars <- names(xlev)\n                mf <- model.frame(x)[facvars]\n                dm <- data.matrix(mf)\n                nlev <- unname(lengths(xlev))\n                ff <- if (nf == 1) \n                  1\n                else rev(cumprod(c(1, nlev[nf:2])))\n                facval <- (dm - 1) %*% ff\n                xx <- facval\n                dev.hold()\n                plot(facval, rs, xlim = c(-1/2, sum((nlev - 1) * \n                  ff) + 1/2), ylim = ylim, xaxt = \"n\", main = main, \n                  xlab = \"Factor Level Combinations\", ylab = ylab5, \n                  type = \"n\", ...)\n                axis(1, at = ff[1L] * (1L:nlev[1L] - 1/2) - 1/2, \n                  labels = xlev[[1L]])\n                mtext(paste(facvars[1L], \":\"), side = 1, line = 0.25, \n                  adj = -0.05)\n                abline(v = ff[1L] * (0:nlev[1L]) - 1/2, col = \"gray\", \n                  lty = \"F4\")\n                panel(facval, rs, ...)\n                abline(h = 0, lty = 3, col = \"gray\")\n                dev.flush()\n            }\n            else {\n                message(gettextf(\"hat values (leverages) are all = %s\\n and there are no factor predictors; no plot no. 5\", \n                  format(mean(r.hat))), domain = NA)\n                frame()\n                do.plot <- FALSE\n            }\n        }\n        else {\n            xx <- hii\n            xx[xx >= 1] <- NA\n            dev.hold()\n            plot(xx, rs, xlim = c(0, max(xx, na.rm = TRUE)), \n                ylim = ylim, main = main, xlab = \"Leverage\", \n                ylab = ylab5, type = \"n\", ...)\n            panel(xx, rs, ...)\n            abline(h = 0, v = 0, lty = 3, col = \"gray\")\n            if (one.fig) \n                title(sub = sub.caption, ...)\n            if (length(cook.levels)) {\n                p <- x$rank\n                usr2 <- par(\"usr\")[2L]\n                hh <- seq.int(min(r.hat[1L], r.hat[2L]/100), \n                  usr2, length.out = 101)\n                for (crit in cook.levels) {\n                  cl.h <- sqrt(crit * p * (1 - hh)/hh)\n                  lines(hh, cl.h, lty = cook.lty, col = cook.col)\n                  lines(hh, -cl.h, lty = cook.lty, col = cook.col)\n                }\n                if (!is.null(cook.legendChanges)) \n                  do.call(legend, modifyList(list(x = \"bottomleft\", \n                    legend = \"Cook's distance\", lty = cook.lty, \n                    col = cook.col, text.col = cook.col, bty = \"n\", \n                    x.intersp = 1/4, y.intersp = 1/8), cook.legendChanges))\n                xmax <- min(0.99, usr2)\n                ymult <- sqrt(p * (1 - xmax)/xmax)\n                aty <- sqrt(cook.levels) * ymult\n                axis(4, at = c(-rev(aty), aty), labels = paste(c(rev(cook.levels), \n                  cook.levels)), mgp = c(0.25, 0.25, 0), las = 2, \n                  tck = 0, cex.axis = cex.id, col.axis = cook.col)\n            }\n            dev.flush()\n        }\n        if (do.plot) {\n            mtext(getCaption(5), 3, 0.25, cex = cex.caption)\n            if (id.n > 0) {\n                y.id <- rs[show.rs]\n                y.id[y.id < 0] <- y.id[y.id < 0] - strheight(\" \")/3\n                text.id(xx[show.rs], y.id, show.rs)\n            }\n        }\n    }\n    if (show[6L]) {\n        g <- dropInf(hii/(1 - hii), hii)\n        ymx <- max(cook, na.rm = TRUE) * 1.025\n        dev.hold()\n        plot(g, cook, xlim = c(0, max(g, na.rm = TRUE)), ylim = c(0, \n            ymx), main = main, ylab = \"Cook's distance\", xlab = expression(\"Leverage  \" * \n            h[ii]), xaxt = \"n\", type = \"n\", ...)\n        panel(g, cook, ...)\n        athat <- pretty(hii)\n        axis(1, at = athat/(1 - athat), labels = paste(athat))\n        if (one.fig) \n            title(sub = sub.caption, ...)\n        p <- x$rank\n        bval <- pretty(sqrt(p * cook/g), 5)\n        usr <- par(\"usr\")\n        xmax <- usr[2L]\n        ymax <- usr[4L]\n        for (i in seq_along(bval)) {\n            bi2 <- bval[i]^2\n            if (p * ymax > bi2 * xmax) {\n                xi <- xmax + strwidth(\" \")/3\n                yi <- bi2 * xi/p\n                abline(0, bi2, lty = cook.lty)\n                text(xi, yi, paste(bval[i]), adj = 0, xpd = TRUE)\n            }\n            else {\n                yi <- ymax - 1.5 * strheight(\" \")\n                xi <- p * yi/bi2\n                lines(c(0, xi), c(0, yi), lty = cook.lty)\n                text(xi, ymax - 0.8 * strheight(\" \"), paste(bval[i]), \n                  adj = 0.5, xpd = TRUE)\n            }\n        }\n        mtext(getCaption(6), 3, 0.25, cex = cex.caption)\n        if (id.n > 0) {\n            show.r <- order(-cook)[iid]\n            text.id(g[show.r], cook[show.r], show.r, usr = usr)\n        }\n        dev.flush()\n    }\n    if (!one.fig && par(\"oma\")[3L] >= 1) \n        mtext(sub.caption, outer = TRUE, cex = cex.oma.main)\n    invisible()\n}\n<bytecode: 0x7f7f829df350>\n<environment: namespace:stats>\n\nlme4:::plot.merMod\n\nfunction (x, form = resid(., type = \"pearson\") ~ fitted(.), abline, \n    id = NULL, idLabels = NULL, grid, ...) \n{\n    object <- x\n    if (!inherits(form, \"formula\")) \n        stop(\"\\\"form\\\" must be a formula\")\n    allV <- all.vars(asOneFormula(form, id, idLabels))\n    allV <- allV[is.na(match(allV, c(\"T\", \"F\", \"TRUE\", \"FALSE\", \n        \".obs\")))]\n    if (length(allV) > 0) {\n        data <- getData(object)\n        if (is.null(data)) {\n            alist <- lapply(as.list(allV), as.name)\n            names(alist) <- allV\n            alist <- c(list(as.name(\"data.frame\")), alist)\n            mode(alist) <- \"call\"\n            data <- eval(alist, sys.parent(1))\n        }\n        else if (any(naV <- is.na(match(allV, names(data))))) \n            stop(allV[naV], \" not found in data\")\n    }\n    else data <- NULL\n    dots <- list(...)\n    args <- if (length(dots) > 0) \n        dots\n    else list()\n    data <- as.list(c(as.list(cbind(data, .obs = seq(nrow(data)))), \n        . = list(object)))\n    covF <- getCovariateFormula(form)\n    .x <- eval(covF[[2]], data)\n    if (!is.numeric(.x)) {\n        stop(\"Covariate must be numeric\")\n    }\n    argForm <- ~.x\n    argData <- data.frame(.x = .x, check.names = FALSE)\n    if (is.null(args$xlab)) {\n        if (is.null(xlab <- attr(.x, \"label\"))) \n            xlab <- deparse(covF[[2]])\n        args$xlab <- xlab\n    }\n    respF <- getResponseFormula(form)\n    if (!is.null(respF)) {\n        .y <- eval(respF[[2]], data)\n        if (is.null(args$ylab)) {\n            if (is.null(ylab <- attr(.y, \"label\"))) \n                ylab <- deparse(respF[[2]])\n            args$ylab <- ylab\n        }\n        argForm <- .y ~ .x\n        argData[, \".y\"] <- .y\n    }\n    grpsF <- getGroupsFormula(form)\n    if (!is.null(grpsF)) {\n        gr <- splitFormula(grpsF, sep = \"*\")\n        for (i in seq_along(gr)) {\n            auxGr <- all.vars(gr[[i]])\n            for (j in auxGr) argData[[j]] <- eval(as.name(j), \n                data)\n        }\n        argForm <- as.formula(paste(if (length(argForm) == 2) \n            \"~ .x |\"\n        else \".y ~ .x |\", deparse(grpsF[[2]])))\n    }\n    args <- c(list(argForm, data = argData), args)\n    if (is.null(args$strip)) {\n        args$strip <- function(...) strip.default(..., style = 1)\n    }\n    if (is.null(args$cex)) \n        args$cex <- par(\"cex\")\n    if (is.null(args$adj)) \n        args$adj <- par(\"adj\")\n    if (!is.null(id)) {\n        idResType <- \"pearson\"\n        id <- switch(mode(id), numeric = {\n            if (id <= 0 || id >= 1) stop(shQuote(\"id\"), \" must be between 0 and 1\")\n            abs(resid(object, type = idResType))/sigma(object) > \n                -qnorm(id/2)\n        }, call = eval(asOneSidedFormula(id)[[2]], data), stop(shQuote(\"id\"), \n            \" can only be a formula or numeric.\"))\n        if (is.null(idLabels)) {\n            idLabels <- getIDLabels(object)\n        }\n        else {\n            if (inherits(idLabels, \"formula\")) {\n                idLabels <- getIDLabels(object, idLabels)\n            }\n            else if (is.vector(idLabels)) {\n                if (length(idLabels <- unlist(idLabels)) != length(id)) {\n                  stop(\"\\\"idLabels\\\" of incorrect length\")\n                }\n            }\n            else stop(\"\\\"idLabels\\\" can only be a formula or a vector\")\n        }\n        idLabels <- as.character(idLabels)\n    }\n    if (missing(abline)) {\n        abline <- if (missing(form)) \n            c(0, 0)\n        else NULL\n    }\n    assign(\"abl\", abline)\n    if (length(argForm) == 3) {\n        if (is.numeric(.y)) {\n            plotFun <- \"xyplot\"\n            if (is.null(args$panel)) {\n                args <- c(args, panel = list(function(x, y, subscripts, \n                  ...) {\n                  x <- as.numeric(x)\n                  y <- as.numeric(y)\n                  dots <- list(...)\n                  if (grid) panel.grid()\n                  panel.xyplot(x, y, ...)\n                  if (any(ids <- id[subscripts])) {\n                    ltext(x[ids], y[ids], idLabels[subscripts][ids], \n                      cex = dots$cex, adj = dots$adj)\n                  }\n                  if (!is.null(abl)) {\n                    if (length(abl) == 2) panel.abline(a = abl, \n                      ...) else panel.abline(h = abl, ...)\n                  }\n                }))\n            }\n        }\n        else {\n            plotFun <- \"bwplot\"\n            if (is.null(args$panel)) {\n                args <- c(args, panel = list(function(x, y, ...) {\n                  if (grid) panel.grid()\n                  panel.bwplot(x, y, ...)\n                  if (!is.null(abl)) {\n                    panel.abline(v = abl[1], ...)\n                  }\n                }))\n            }\n        }\n    }\n    else {\n        plotFun <- \"histogram\"\n        if (is.null(args$panel)) {\n            args <- c(args, panel = list(function(x, ...) {\n                if (grid) panel.grid()\n                panel.histogram(x, ...)\n                if (!is.null(abl)) {\n                  panel.abline(v = abl[1], ...)\n                }\n            }))\n        }\n    }\n    if (missing(grid)) {\n        grid <- (plotFun == \"xyplot\")\n    }\n    do.call(plotFun, as.list(args))\n}\n<bytecode: 0x7f7f85beb078>\n<environment: namespace:lme4>"
  }
]